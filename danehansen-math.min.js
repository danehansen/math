/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["danehansen"] = factory();
	else
		root["danehansen"] = root["danehansen"] || {}, root["danehansen"]["math"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/math.js":
/*!*********************!*\
  !*** ./src/math.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"average\": () => (/* binding */ average),\n/* harmony export */   \"ceil\": () => (/* binding */ ceil),\n/* harmony export */   \"circleIntersection\": () => (/* binding */ circleIntersection),\n/* harmony export */   \"ease\": () => (/* binding */ ease),\n/* harmony export */   \"easeProp\": () => (/* binding */ easeProp),\n/* harmony export */   \"euclid\": () => (/* binding */ euclid),\n/* harmony export */   \"floor\": () => (/* binding */ floor),\n/* harmony export */   \"intLength\": () => (/* binding */ intLength),\n/* harmony export */   \"luhn\": () => (/* binding */ luhn),\n/* harmony export */   \"modulo\": () => (/* binding */ modulo),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"primes\": () => (/* binding */ primes),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"randomItem\": () => (/* binding */ randomItem),\n/* harmony export */   \"randomDirection\": () => (/* binding */ randomDirection),\n/* harmony export */   \"randomBoolean\": () => (/* binding */ randomBoolean),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"shuffle\": () => (/* binding */ shuffle),\n/* harmony export */   \"sortAscending\": () => (/* binding */ sortAscending),\n/* harmony export */   \"sortDescending\": () => (/* binding */ sortDescending),\n/* harmony export */   \"splitUint\": () => (/* binding */ splitUint),\n/* harmony export */   \"toDegrees\": () => (/* binding */ toDegrees),\n/* harmony export */   \"toDegreeDirection\": () => (/* binding */ toDegreeDirection),\n/* harmony export */   \"toRadians\": () => (/* binding */ toRadians),\n/* harmony export */   \"toRadianDirection\": () => (/* binding */ toRadianDirection),\n/* harmony export */   \"total\": () => (/* binding */ total)\n/* harmony export */ });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction average() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var first = args[0];\n  var array = typeof first === \"number\" ? args : first;\n  var total = 0;\n\n  var _iterator = _createForOfIteratorHelper(array),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _float = _step.value;\n      total += _float;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return total / array.length;\n}\nfunction ceil(num) {\n  var increment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return increment * Math.ceil(num / increment);\n}\nfunction circleIntersection(centerA, radiusA, centerB, radiusB) {\n  var dx = centerB.x - centerA.x;\n  var dy = centerB.y - centerA.y;\n  var d = Math.sqrt(dy * dy + dx * dx);\n\n  if (d > radiusA + radiusB || d < Math.abs(radiusA - radiusB)) {\n    return [];\n  }\n\n  var a = (radiusA * radiusA - radiusB * radiusB + d * d) / (2 * d);\n  var x2 = centerA.x + dx * a / d;\n  var y2 = centerA.y + dy * a / d;\n  var h = Math.sqrt(radiusA * radiusA - a * a);\n  var rx = -dy * (h / d);\n  var ry = dx * (h / d);\n  var i1 = {\n    x: x2 + rx,\n    y: y2 + ry\n  };\n  var i2 = {\n    x: x2 - rx,\n    y: y2 - ry\n  };\n  var points = [i1];\n\n  if (i1.x !== i2.x || i1.y !== i2.y) {\n    points.push(i2);\n  }\n\n  return points;\n}\nfunction ease(current, dest) {\n  var speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.05;\n  return current += (dest - current) * speed;\n}\nfunction easeProp(targ, key, dest, speed) {\n  var current = ease(targ[key], dest, speed);\n  targ[key] = current;\n  return current;\n}\nfunction euclid(a, b) {\n  if (b === 0) {\n    return a;\n  } else {\n    return euclid(b, a % b);\n  }\n}\nfunction floor(num) {\n  var increment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return increment * Math.floor(num / increment);\n}\nfunction intLength(num) {\n  if (!num) {\n    return 0;\n  }\n\n  var abs = Math.abs(num);\n  var len = Math.ceil(Math.log(abs) / Math.LN10);\n  var log = Math.log10(abs);\n\n  if (log === Math.floor(log)) {\n    len++;\n  }\n\n  return len;\n}\nfunction luhn(num) {\n  var check;\n  var even = true;\n  var total = 0;\n\n  while (num > 1) {\n    var d = num % 10;\n    num = (num - d) / 10;\n\n    if (check === undefined) {\n      check = d;\n    } else {\n      if (!even) {\n        d *= 2;\n\n        if (d > 9) {\n          d -= 9;\n        }\n      }\n\n      total += d;\n    }\n\n    even = !even;\n  }\n\n  var numCheck = (10 - total % 10) % 10;\n  return check === numCheck;\n}\nfunction modulo(num, limit) {\n  if (!limit) {\n    return 0;\n  }\n\n  var mod = num % limit;\n\n  if (num >= 0) {\n    return mod;\n  } else if (mod < 0) {\n    return (mod + limit) % limit;\n  } else {\n    return 0;\n  }\n}\nfunction normalize(low, high, value) {\n  return (value - low) / (high - low);\n}\nfunction primes(limit) {\n  var sieve = [];\n  var primes = [];\n\n  for (var i = 2; i <= limit; ++i) {\n    if (!sieve[i]) {\n      primes.push(i);\n\n      for (var j = i * 2; j <= limit; j += i) {\n        sieve[j] = true;\n      }\n    }\n  }\n\n  return primes;\n}\nfunction random() {\n  var limitA = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var limitB = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var round = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var choke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var total = 0;\n\n  if (!round) {\n    for (var i = 0; i < choke; i++) {\n      total += Math.random() * ((limitB - limitA) / choke);\n    }\n\n    return limitA + total;\n  } else {\n    var low = Math.ceil(Math.min(limitA, limitB));\n    var high = Math.floor(Math.max(limitA, limitB));\n\n    for (var _i = 0; _i < choke; _i++) {\n      total += Math.random() * ((high + 1 - low) / choke);\n    }\n\n    return Math.floor(low + total);\n  }\n}\nfunction randomItem(array) {\n  var choke = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return array[random(0, array.length - 1, true, choke)];\n}\nfunction randomDirection() {\n  return Math.random() > 0.5 ? 1 : -1;\n}\nfunction randomBoolean() {\n  return Math.random() > 0.5 ? true : false;\n}\nfunction round(num) {\n  var increment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return increment * Math.round(num / increment);\n}\nfunction shuffle(array, duplicate) {\n  var shuffledArray = duplicate ? _toConsumableArray(array) : array;\n\n  for (var i = 0, length = array.length; i < length; i++) {\n    var randomIndex = Math.floor(Math.random() * (length - i));\n    var dest = shuffledArray[length - 1 - i];\n    shuffledArray[length - 1 - i] = shuffledArray[randomIndex];\n    shuffledArray[randomIndex] = dest;\n  }\n\n  return shuffledArray;\n}\nfunction sortAscending(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\nfunction sortDescending(a, b) {\n  return a > b ? -1 : a < b ? 1 : 0;\n}\nfunction splitUint(num) {\n  var length = intLength(num);\n  var split = [];\n\n  for (var i = 0; i < length; i++) {\n    var d = num % 10;\n    split.unshift(d);\n    num = (num - d) / 10;\n  }\n\n  return split;\n}\nfunction toDegrees(radians) {\n  return radians * 180 / Math.PI;\n}\nfunction toDegreeDirection(radians) {\n  var degrees = toDegrees(-radians);\n  return modulo(degrees + 90, 360);\n}\nfunction toRadians(degrees) {\n  return degrees * Math.PI / 180;\n}\nfunction toRadianDirection(degrees) {\n  var circ = Math.PI * 2;\n  var radians = toRadians(-degrees);\n  var offset = radians + circ * 0.25;\n  return modulo(offset, circ);\n}\nfunction total(array) {\n  var sum = 0;\n\n  for (var i = 0, length = array.length; i < length; i++) {\n    var value = array[i];\n\n    if (typeof value === \"number\" && !isNaN(value)) {\n      sum += value;\n    } else if (value) {\n      sum++;\n    }\n  }\n\n  return sum;\n}\n\n//# sourceURL=webpack://danehansen.math/./src/math.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/math.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
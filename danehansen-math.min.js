/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["danehansen"] = factory();
	else
		root["danehansen"] = root["danehansen"] || {}, root["danehansen"]["math"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/math.ts":
/*!*********************!*\
  !*** ./src/math.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nexports.__esModule = true;\nexports.total = exports.toRadianDirection = exports.toRadians = exports.toDegreeDirection = exports.toDegrees = exports.splitUint = exports.sortDescending = exports.sortAscending = exports.shuffle = exports.round = exports.randomBoolean = exports.randomDirection = exports.randomItem = exports.random = exports.primes = exports.normalize = exports.modulo = exports.luhn = exports.intLength = exports.floor = exports.euclid = exports.easeProp = exports.ease = exports.circleIntersection = exports.ceil = exports.average = void 0;\nfunction average() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var first = args[0];\n    var array = typeof first === \"number\" ? args : first;\n    var total = 0;\n    for (var _a = 0, array_1 = array; _a < array_1.length; _a++) {\n        var float = array_1[_a];\n        total += float;\n    }\n    return total / array.length;\n}\nexports.average = average;\nfunction ceil(num, increment) {\n    if (increment === void 0) { increment = 1; }\n    return increment * Math.ceil(num / increment);\n}\nexports.ceil = ceil;\nfunction circleIntersection(centerA, radiusA, centerB, radiusB) {\n    var dx = centerB.x - centerA.x;\n    var dy = centerB.y - centerA.y;\n    var d = Math.sqrt(dy * dy + dx * dx);\n    if (d > radiusA + radiusB || d < Math.abs(radiusA - radiusB)) {\n        return [];\n    }\n    var a = (radiusA * radiusA - radiusB * radiusB + d * d) / (2 * d);\n    var x2 = centerA.x + (dx * a) / d;\n    var y2 = centerA.y + (dy * a) / d;\n    var h = Math.sqrt(radiusA * radiusA - a * a);\n    var rx = -dy * (h / d);\n    var ry = dx * (h / d);\n    var i1 = {\n        x: x2 + rx,\n        y: y2 + ry\n    };\n    var i2 = {\n        x: x2 - rx,\n        y: y2 - ry\n    };\n    var points = [i1];\n    if (i1.x !== i2.x || i1.y !== i2.y) {\n        points.push(i2);\n    }\n    return points;\n}\nexports.circleIntersection = circleIntersection;\nfunction ease(current, dest, speed) {\n    if (speed === void 0) { speed = 0.05; }\n    return (current += (dest - current) * speed);\n}\nexports.ease = ease;\nfunction easeProp(targ, key, dest, speed) {\n    var current = ease(targ[key], dest, speed);\n    targ[key] = current;\n    return current;\n}\nexports.easeProp = easeProp;\nfunction euclid(a, b) {\n    if (b === 0) {\n        return a;\n    }\n    else {\n        return euclid(b, a % b);\n    }\n}\nexports.euclid = euclid;\nfunction floor(num, increment) {\n    if (increment === void 0) { increment = 1; }\n    return increment * Math.floor(num / increment);\n}\nexports.floor = floor;\nfunction intLength(num) {\n    if (!num) {\n        return 0;\n    }\n    var abs = Math.abs(num);\n    var len = Math.ceil(Math.log(abs) / Math.LN10);\n    var log = Math.log10(abs);\n    if (log === Math.floor(log)) {\n        len++;\n    }\n    return len;\n}\nexports.intLength = intLength;\nfunction luhn(num) {\n    var check;\n    var even = true;\n    var total = 0;\n    while (num > 1) {\n        var d = num % 10;\n        num = (num - d) / 10;\n        if (check === undefined) {\n            check = d;\n        }\n        else {\n            if (!even) {\n                d *= 2;\n                if (d > 9) {\n                    d -= 9;\n                }\n            }\n            total += d;\n        }\n        even = !even;\n    }\n    var numCheck = (10 - (total % 10)) % 10;\n    return check === numCheck;\n}\nexports.luhn = luhn;\nfunction modulo(num, limit) {\n    if (!limit) {\n        return 0;\n    }\n    var mod = num % limit;\n    if (num >= 0) {\n        return mod;\n    }\n    else if (mod < 0) {\n        return (mod + limit) % limit;\n    }\n    else {\n        return 0;\n    }\n}\nexports.modulo = modulo;\nfunction normalize(low, high, value) {\n    return (value - low) / (high - low);\n}\nexports.normalize = normalize;\nfunction primes(limit) {\n    var sieve = [];\n    var primes = [];\n    for (var i = 2; i <= limit; ++i) {\n        if (!sieve[i]) {\n            primes.push(i);\n            for (var j = i * 2; j <= limit; j += i) {\n                sieve[j] = true;\n            }\n        }\n    }\n    return primes;\n}\nexports.primes = primes;\nfunction random(limitA, limitB, round, choke) {\n    if (limitA === void 0) { limitA = 1; }\n    if (limitB === void 0) { limitB = 0; }\n    if (round === void 0) { round = false; }\n    if (choke === void 0) { choke = 1; }\n    var total = 0;\n    if (!round) {\n        for (var i = 0; i < choke; i++) {\n            total += Math.random() * ((limitB - limitA) / choke);\n        }\n        return limitA + total;\n    }\n    else {\n        var low = Math.ceil(Math.min(limitA, limitB));\n        var high = Math.floor(Math.max(limitA, limitB));\n        for (var i = 0; i < choke; i++) {\n            total += Math.random() * ((high + 1 - low) / choke);\n        }\n        return Math.floor(low + total);\n    }\n}\nexports.random = random;\nfunction randomItem(array, choke) {\n    if (choke === void 0) { choke = 1; }\n    return array[random(0, array.length - 1, true, choke)];\n}\nexports.randomItem = randomItem;\nfunction randomDirection() {\n    return Math.random() > 0.5 ? 1 : -1;\n}\nexports.randomDirection = randomDirection;\nfunction randomBoolean() {\n    return Math.random() > 0.5 ? true : false;\n}\nexports.randomBoolean = randomBoolean;\nfunction round(num, increment) {\n    if (increment === void 0) { increment = 1; }\n    return increment * Math.round(num / increment);\n}\nexports.round = round;\nfunction shuffle(array, duplicate) {\n    var shuffledArray = duplicate ? __spreadArray([], array, true) : array;\n    for (var i = 0, length_1 = array.length; i < length_1; i++) {\n        var randomIndex = Math.floor(Math.random() * (length_1 - i));\n        var dest = shuffledArray[length_1 - 1 - i];\n        shuffledArray[length_1 - 1 - i] = shuffledArray[randomIndex];\n        shuffledArray[randomIndex] = dest;\n    }\n    return shuffledArray;\n}\nexports.shuffle = shuffle;\nfunction sortAscending(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n}\nexports.sortAscending = sortAscending;\nfunction sortDescending(a, b) {\n    return a > b ? -1 : a < b ? 1 : 0;\n}\nexports.sortDescending = sortDescending;\nfunction splitUint(num) {\n    var length = intLength(num);\n    var split = [];\n    for (var i = 0; i < length; i++) {\n        var d = num % 10;\n        split.unshift(d);\n        num = (num - d) / 10;\n    }\n    return split;\n}\nexports.splitUint = splitUint;\nfunction toDegrees(radians) {\n    return radians * 180 / Math.PI;\n}\nexports.toDegrees = toDegrees;\nfunction toDegreeDirection(radians) {\n    var degrees = toDegrees(-radians);\n    return modulo(degrees + 90, 360);\n}\nexports.toDegreeDirection = toDegreeDirection;\nfunction toRadians(degrees) {\n    return degrees * Math.PI / 180;\n}\nexports.toRadians = toRadians;\nfunction toRadianDirection(degrees) {\n    var circ = Math.PI * 2;\n    var radians = toRadians(-degrees);\n    var offset = radians + circ * 0.25;\n    return modulo(offset, circ);\n}\nexports.toRadianDirection = toRadianDirection;\nfunction total(array) {\n    var sum = 0;\n    for (var i = 0, length_2 = array.length; i < length_2; i++) {\n        var value = array[i];\n        if (typeof value === \"number\" && !isNaN(value)) {\n            sum += value;\n        }\n        else if (value) {\n            sum++;\n        }\n    }\n    return sum;\n}\nexports.total = total;\n\n\n//# sourceURL=webpack://danehansen.math/./src/math.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/math.ts"](0, __webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
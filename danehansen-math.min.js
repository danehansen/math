/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["danehansen"] = factory();
	else
		root["danehansen"] = root["danehansen"] || {}, root["danehansen"]["math"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/math.ts":
/*!*********************!*\
  !*** ./src/math.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   average: () => (/* binding */ average),\n/* harmony export */   ceil: () => (/* binding */ ceil),\n/* harmony export */   circleIntersection: () => (/* binding */ circleIntersection),\n/* harmony export */   ease: () => (/* binding */ ease),\n/* harmony export */   easeProp: () => (/* binding */ easeProp),\n/* harmony export */   euclid: () => (/* binding */ euclid),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   intLength: () => (/* binding */ intLength),\n/* harmony export */   luhn: () => (/* binding */ luhn),\n/* harmony export */   modulo: () => (/* binding */ modulo),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   primes: () => (/* binding */ primes),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   randomBoolean: () => (/* binding */ randomBoolean),\n/* harmony export */   randomDirection: () => (/* binding */ randomDirection),\n/* harmony export */   randomItem: () => (/* binding */ randomItem),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   shuffle: () => (/* binding */ shuffle),\n/* harmony export */   sortAscending: () => (/* binding */ sortAscending),\n/* harmony export */   sortDescending: () => (/* binding */ sortDescending),\n/* harmony export */   splitUint: () => (/* binding */ splitUint),\n/* harmony export */   toDegreeDirection: () => (/* binding */ toDegreeDirection),\n/* harmony export */   toDegrees: () => (/* binding */ toDegrees),\n/* harmony export */   toRadianDirection: () => (/* binding */ toRadianDirection),\n/* harmony export */   toRadians: () => (/* binding */ toRadians),\n/* harmony export */   total: () => (/* binding */ total)\n/* harmony export */ });\nfunction average(...args) {\n    const first = args[0];\n    const array = typeof first === \"number\" ? args : first;\n    let total = 0;\n    for (let float of array) {\n        total += float;\n    }\n    return total / array.length;\n}\nfunction ceil(num, increment = 1) {\n    return increment * Math.ceil(num / increment);\n}\nfunction circleIntersection(centerA, radiusA, centerB, radiusB) {\n    const dx = centerB.x - centerA.x;\n    const dy = centerB.y - centerA.y;\n    const d = Math.sqrt(dy * dy + dx * dx);\n    if (d > radiusA + radiusB || d < Math.abs(radiusA - radiusB)) {\n        return [];\n    }\n    const a = (radiusA * radiusA - radiusB * radiusB + d * d) / (2 * d);\n    const x2 = centerA.x + (dx * a) / d;\n    const y2 = centerA.y + (dy * a) / d;\n    const h = Math.sqrt(radiusA * radiusA - a * a);\n    const rx = -dy * (h / d);\n    const ry = dx * (h / d);\n    const i1 = {\n        x: x2 + rx,\n        y: y2 + ry\n    };\n    const i2 = {\n        x: x2 - rx,\n        y: y2 - ry\n    };\n    const points = [i1];\n    if (i1.x !== i2.x || i1.y !== i2.y) {\n        points.push(i2);\n    }\n    return points;\n}\nfunction ease(current, dest, speed = 0.05) {\n    return (current += (dest - current) * speed);\n}\nfunction easeProp(targ, key, dest, speed) {\n    const current = ease(targ[key], dest, speed);\n    targ[key] = current;\n    return current;\n}\nfunction euclid(a, b) {\n    if (b === 0) {\n        return a;\n    }\n    else {\n        return euclid(b, a % b);\n    }\n}\nfunction floor(num, increment = 1) {\n    return increment * Math.floor(num / increment);\n}\nfunction intLength(num) {\n    if (!num) {\n        return 0;\n    }\n    const abs = Math.abs(num);\n    let len = Math.ceil(Math.log(abs) / Math.LN10);\n    const log = Math.log10(abs);\n    if (log === Math.floor(log)) {\n        len++;\n    }\n    return len;\n}\nfunction luhn(num) {\n    let check;\n    let even = true;\n    let total = 0;\n    while (num > 1) {\n        let d = num % 10;\n        num = (num - d) / 10;\n        if (check === undefined) {\n            check = d;\n        }\n        else {\n            if (!even) {\n                d *= 2;\n                if (d > 9) {\n                    d -= 9;\n                }\n            }\n            total += d;\n        }\n        even = !even;\n    }\n    const numCheck = (10 - (total % 10)) % 10;\n    return check === numCheck;\n}\nfunction modulo(num, limit) {\n    if (!limit) {\n        return 0;\n    }\n    const mod = num % limit;\n    if (num >= 0) {\n        return mod;\n    }\n    else if (mod < 0) {\n        return (mod + limit) % limit;\n    }\n    else {\n        return 0;\n    }\n}\nfunction normalize(low, high, value) {\n    return (value - low) / (high - low);\n}\nfunction primes(limit) {\n    const sieve = [];\n    const primes = [];\n    for (let i = 2; i <= limit; ++i) {\n        if (!sieve[i]) {\n            primes.push(i);\n            for (let j = i * 2; j <= limit; j += i) {\n                sieve[j] = true;\n            }\n        }\n    }\n    return primes;\n}\nfunction random(limitA = 1, limitB = 0, round = false, choke = 1) {\n    let total = 0;\n    if (!round) {\n        for (let i = 0; i < choke; i++) {\n            total += Math.random() * ((limitB - limitA) / choke);\n        }\n        return limitA + total;\n    }\n    else {\n        const low = Math.ceil(Math.min(limitA, limitB));\n        const high = Math.floor(Math.max(limitA, limitB));\n        for (let i = 0; i < choke; i++) {\n            total += Math.random() * ((high + 1 - low) / choke);\n        }\n        return Math.floor(low + total);\n    }\n}\nfunction randomItem(array, choke = 1) {\n    return array[random(0, array.length - 1, true, choke)];\n}\nfunction randomDirection() {\n    return Math.random() > 0.5 ? 1 : -1;\n}\nfunction randomBoolean() {\n    return Math.random() > 0.5 ? true : false;\n}\nfunction round(num, increment = 1) {\n    return increment * Math.round(num / increment);\n}\nfunction shuffle(array, duplicate) {\n    const shuffledArray = duplicate ? [...array] : array;\n    for (let i = 0, length = array.length; i < length; i++) {\n        const randomIndex = Math.floor(Math.random() * (length - i));\n        const dest = shuffledArray[length - 1 - i];\n        shuffledArray[length - 1 - i] = shuffledArray[randomIndex];\n        shuffledArray[randomIndex] = dest;\n    }\n    return shuffledArray;\n}\nfunction sortAscending(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n}\nfunction sortDescending(a, b) {\n    return a > b ? -1 : a < b ? 1 : 0;\n}\nfunction splitUint(num) {\n    const length = intLength(num);\n    const split = [];\n    for (let i = 0; i < length; i++) {\n        const d = num % 10;\n        split.unshift(d);\n        num = (num - d) / 10;\n    }\n    return split;\n}\nfunction toDegrees(radians) {\n    return radians * 180 / Math.PI;\n}\nfunction toDegreeDirection(radians) {\n    const degrees = toDegrees(-radians);\n    return modulo(degrees + 90, 360);\n}\nfunction toRadians(degrees) {\n    return degrees * Math.PI / 180;\n}\nfunction toRadianDirection(degrees) {\n    const circ = Math.PI * 2;\n    const radians = toRadians(-degrees);\n    const offset = radians + circ * 0.25;\n    return modulo(offset, circ);\n}\nfunction total(array) {\n    let sum = 0;\n    for (let i = 0, length = array.length; i < length; i++) {\n        const value = array[i];\n        if (typeof value === \"number\" && !isNaN(value)) {\n            sum += value;\n        }\n        else if (value) {\n            sum++;\n        }\n    }\n    return sum;\n}\n\n\n//# sourceURL=webpack://danehansen.math/./src/math.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/math.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});